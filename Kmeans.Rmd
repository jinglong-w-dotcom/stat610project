---
title: "Kmeans"
author: "Yijia Li"
date: "2024-11-19"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

initial cluster assigments
```{r}
intial_cluster <- function(data, K){
  row <- nrow(data) 
  col <- ncol(data)
  random_value <- sample(1:K, row, replace = TRUE)
  intial_cluster_random <- cbind(data, random_value)
  for (i in 1:K) {
    if (!i %in% intial_cluster_random) {
      freq_table <- table(intial_cluster_random)
      repeated_elements <- names(freq_table[freq_table > 1])
      random_element <- sample(repeated_elements, 1)
      random_index <- sample(which(intial_cluster_random == random_element), 1)
      intial_cluster_random[random_index] <- i
      }
  }
  initial_cluster_list <- list()
  for (i in 1:K) {
    cluster <- intial_cluster_random[intial_cluster_random[, col+1] == i, 1:col, drop = FALSE]
    initial_cluster_list[[i]] <- cluster 
  }
  return(initial_cluster_list)
}
```

```{r}
current_cluster <- function(klist, data){
  cluster_centroid <- matrix(0, nrow = length(klist), ncol = ncol(klist[[1]]))
  c <- ncol(klist[[1]])
  for (k in 1:length(klist)) {
    for (j in 1:c) {
    cluster_centroid[k, j] <- mean(klist[[k]][, j])
    }
  }
  #Assign each observation to the cluster whose centroid is closet
  
  distance_square_matric <- matrix(NA, nrow = nrow(data), ncol = length(klist))
  for (i in 1:nrow(data)) {
    for (k in 1:length(klist)) {
      distance_square <- 0
      for (j in 1:ncol(data)) {
        f <- (data[i,j]-cluster_centroid[k,j])^2
        distance_square <- distance_square + f
        
      }
      distance_square_matric[i,k] <- distance_square
      
    }
    
  }
  min_positions <- apply(distance_square_matric, 1, which.min)
  for (i in 1:length(klist)) {
    if (!i %in% min_positions) {
      freq_table <- table(min_positions)
      repeated_elements <- names(freq_table[freq_table > 1])
      random_element <- sample(repeated_elements, 1)
      random_index <- sample(which(min_positions == random_element), 1)
      min_positions[random_index] <- i
      }
  }
  current_cluster_min <- cbind(data, min_positions)
  current_list <- list()
  for (i in 1:length(klist)) {
    cluster <- current_cluster_min[current_cluster_min[, ncol(klist[[1]])+1] == i, 1:c, drop = FALSE]
    current_list[[i]] <- cluster
  }
  return(current_list)
}
```



```{r}
WCk <- function(data){
  row <- nrow(data) 
  col <- ncol(data)
  cluster_centroid <- rep(NA, col)
  for (j in 1:col) {
    cluster_centroid[j] <- mean(data[, j])
  }
  squared_dist <- 0
  for (i in 1:row) {
    distance_square <- 0
    
    for (j in 1:col) {
      a <- (data[i, j] - cluster_centroid[j])^2
      distance_square <- distance_square + a
    }
    squared_dist <- squared_dist + distance_square
  }
  a_cluster_difference <- 2 * squared_dist
  return(a_cluster_difference)
}

WC_sum <- function(klist){
  cluster_difference <- 0
  K <- length(klist)
  for (k in 1:K) {
    b <- WCk(klist[[k]])
    cluster_difference <- cluster_difference + b
  }
  return(cluster_difference)
}
#the purpose is to minimize WCk
```


plot scatter
```{r}
plot_scatter <- function(klist, x_min, x_max, y_min, y_max){
  x <- round(WC_sum(klist), 2)
  plot(klist[[1]][, 1], klist[[1]][, 2], type = "p", col = 1, pch = 16, xlab = "feature 1", ylab = "feature 2", main = paste("Within-cluster variation is", x), xlim = c(x_min, x_max), ylim = c(y_min, y_max)) 
  K <- length(klist)
  for (i in 2:K) {
    if(K == 1){
      break
    }
    points(klist[[i]][, 1], klist[[i]][, 2], col = i, pch = 16)
  }
  cluster_centroid <- matrix(0, nrow = length(klist), ncol = ncol(klist[[1]]))
  for (k in 1:length(klist)) {
    r <- nrow(klist[[k]])
    c <- ncol(klist[[k]])
    for (j in 1:c) {
    cluster_centroid[k, j] <- mean(klist[[k]][, j])
    }
  }
  points(cluster_centroid[, 1], cluster_centroid[ , 2], col = 12, pch = 4, cex = 2)
}
```


```{r}
#Kmeans function returns the record of process
Kmeans_function <- function(data, K, N, iteration = 100){
   if(nrow(data) < K){
    stop("The number of cluster centers is greater than the number of data points.")
    }
  
  iteration_list <- list()
  optimal_WC <- rep(NA, iteration)
  cluster_list <- list()
  for (iterate in 1:iteration) {
    
    initial_cluster_list <- intial_cluster(data, K)
    current_cluster_list <- current_cluster(initial_cluster_list, data)
    history <- list()
    history[[1]] <- initial_cluster_list
    history[[2]] <- current_cluster_list
    for (i in 1:(N-1)) {
      new_cluster_list <- current_cluster(current_cluster_list, data)
      #When the change of WCk is small, the function break
      sum_WCk_new <- WC_sum(new_cluster_list)
      sum_WCk_past <- WC_sum(current_cluster_list)
      if(round(sum_WCk_past, 6) == round(sum_WCk_new, 6)){
        break
        }
      current_cluster_list <- new_cluster_list
      history[[i+2]] <- current_cluster_list
      }
    cluster_list[[iterate]] <- history
    optimal_WC[iterate] <- WC_sum(history[[length(history)]])
    }
  
  result_list <- cluster_list[[which.min(optimal_WC)]]
  cluster_list <- lapply(cluster_list, function(sublist) tail(sublist, 1)[[1]])
  
  return(list(result_list, cluster_list))
  }
#should record the history and return the list, after running the function, plot the gif
```

the plot of the algorithm progresses
```{r}
#install.packages("animation")
library(animation)

plot_animation <- function(history, data) {
  x_min <- min(data[,1])
  x_max <- max(data[,1])
  y_min <- min(data[,2])
  y_max <- max(data[,2])
  saveGIF({
    for (i in 1:length(history)) {
      plot_scatter(history[[i]], x_min, x_max, y_min, y_max)
      title(main = paste("Iteration:", i), line = -1)
    }
  }, movie.name = "kmeans.gif", interval = 1, ani.width = 800, ani.height = 600)
}

result <- Kmeans_function(x, 15, 200, iteration = 100)
plot_animation(result[[1]], x)

p <- rep(NA, length(result[[2]]))
for (i in 1:length(result[[2]])) {
  p[i] <- WC_sum(result[[2]][[i]])
  
}
hist(p, breaks = 5, col = "green", xlab = "WCSS", main = "frequancy", freq = TRUE)

```




choice k function
```{r}
Kmeans_quality_measure <- function(K_range, data, N = 100){
  m <- rep(NA, K_range) #to record the sum of WCk in difference K value
  x_min <- min(data[,1])
  x_max <- max(data[,1])
  y_min <- min(data[,2])
  y_max <- max(data[,2])
  for (a in 1:K_range) {
    result <- Kmeans_function(data, a, N, iteration = 100)
    final_list <- result[[1]][[length(result[[1]])]]
    m[a] <- round(WC_sum(final_list), 2)
    plot_scatter(final_list, x_min, x_max, y_min, y_max)
    iteration_text <- paste("Iterations:", a)
    legend("topright", legend = iteration_text, bty = "n", cex = 1.2, col = "black")
  }
  k_value <- 1:K_range
  plot(k_value, m, type = "b", col = "blue", pch = 16, xlab = "value of K", ylab = "Within-Cluster Sum of Squares")
  return(m)
}
Kmeans_quality_measure(15, x)

```


